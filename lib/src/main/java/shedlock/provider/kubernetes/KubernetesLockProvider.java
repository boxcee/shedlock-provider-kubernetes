/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package shedlock.provider.kubernetes;

import io.fabric8.kubernetes.api.model.ConfigMap;
import io.fabric8.kubernetes.api.model.ConfigMapBuilder;
import io.fabric8.kubernetes.client.KubernetesClientException;
import io.fabric8.kubernetes.client.NamespacedKubernetesClient;
import net.javacrumbs.shedlock.core.LockConfiguration;
import net.javacrumbs.shedlock.core.LockProvider;
import net.javacrumbs.shedlock.core.SimpleLock;
import net.javacrumbs.shedlock.support.LockException;
import net.javacrumbs.shedlock.support.annotation.NonNull;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.Optional;

public class KubernetesLockProvider implements LockProvider {

  public static final String CONFIG_MAP_PREFIX = "shedlock";
  public static final String LOCKED_BY = "lockedBy";
  public static final String LOCKED_AT = "lockedAt";
  public static final String LOCK_AT_LEAST_FOR = "lockAtLeastFor";
  public static final String LOCK_AT_MOST_FOR = "lockAtMostFor";

  private final NamespacedKubernetesClient client;
  private final String hostname;

  public KubernetesLockProvider(@NonNull NamespacedKubernetesClient client, String hostname) {
    if (hostname == null || hostname.trim().isEmpty()) {
      throw new LockException("'HOSTNAME' not set. Are you sure you are running in a k8s environment?");
    }
    this.client = client;
    this.hostname = hostname;
  }

  public KubernetesLockProvider(@NonNull NamespacedKubernetesClient client) {
    this(client, System.getenv("HOSTNAME"));
  }

  public static String getConfigMapName(LockConfiguration lockConfiguration) {
    return String.format("%s-%s", CONFIG_MAP_PREFIX, lockConfiguration.getName()).trim().toLowerCase();
  }

  @Override
  public Optional<SimpleLock> lock(LockConfiguration lockConfiguration) {
    LocalDateTime now = LocalDateTime.now();
    String configMapName = getConfigMapName(lockConfiguration);

    ConfigMap existingConfigMap = null;
    try {
      existingConfigMap = client.configMaps().withName(configMapName).get();
    } catch (KubernetesClientException kce) {
      // ConfigMap does not exist. Continue...
    }

    // ConfigMap does not exist. Lock is not held by any process.
    if (existingConfigMap == null) {
      ConfigMap newConfigMap = buildConfigMap(lockConfiguration, now);
      try {
        client.configMaps().create(newConfigMap);
      } catch (KubernetesClientException kce) {
        // ConfigMap was created in the meantime. Some other process holds the lock. Return empty.
        return Optional.empty();
      }
      return Optional.of(new KubernetesLock(client, lockConfiguration, now));
    }

    if (canBeLocked(existingConfigMap, now)) {
      ConfigMap newConfigMap = buildConfigMap(lockConfiguration, now);
      try {
        // Replace existing configMap.
        client.configMaps().withName(configMapName).replace(newConfigMap);
      } catch (KubernetesClientException kce) {
        throw new LockException("Unexpected error occurred", kce);
      }
      return Optional.of(new KubernetesLock(client, lockConfiguration, now));
    }

    return Optional.empty();
  }

  private boolean canBeLocked(ConfigMap existingConfigMap, LocalDateTime now) {
    final Map<String, String> existingAnnotations = existingConfigMap.getMetadata().getAnnotations();
    final LocalDateTime lockedAt = LocalDateTime.parse(existingAnnotations.get(LOCKED_AT));
    final Duration lockAtLeastFor = Duration.ofMillis(Long.parseLong(existingAnnotations.get(LOCK_AT_LEAST_FOR)));
    final Duration lockAtMostFor = Duration.ofMillis(Long.parseLong(existingAnnotations.get(LOCK_AT_MOST_FOR)));
    return now.isAfter(lockedAt.plus(lockAtLeastFor)) && now.isAfter(lockedAt.plus(lockAtMostFor));
  }

  private ConfigMap buildConfigMap(LockConfiguration lockConfiguration, LocalDateTime now) {
    return new ConfigMapBuilder()
        .editOrNewMetadata()
        .withName(getConfigMapName(lockConfiguration))
        .addToAnnotations(LOCKED_BY, hostname)
        .addToAnnotations(LOCKED_AT, String.valueOf(now))
        .addToAnnotations(LOCK_AT_LEAST_FOR, String.valueOf(lockConfiguration.getLockAtLeastFor().toMillis()))
        .addToAnnotations(LOCK_AT_MOST_FOR, String.valueOf(lockConfiguration.getLockAtMostFor().toMillis()))
        .endMetadata()
        .build();
  }
}
